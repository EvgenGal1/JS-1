// ждем когда всё загрузится и потом выполняем
window.addEventListener("load", () => {
  // объект класса settings
  // объект настроек
  const settings = new Settings();
  // статус
  const status = new Status();
  // объект змейки
  const snake = new Snake();
  // объект (класс) игрового поля
  const board = new Board();
  // объект меню. отвечает за работу кнопок (старт, пауза)
  const menu = new Menu();
  // еда
  const food = new Food();
  // объект игры
  const game = new Game();
  //   const score = new Score();

  //! передаем свои настройки
  // в классе settings метод init (установка начальных значений). в виде объекта передаем настройки для нашей игры(скорость, длина для выйгрыша)
  settings.init({ speed: 5, winLength: 5 });

  //
  //   snake.init(settings);

  //! передаем в board через init, настройки и змейку
  board.init(settings, snake);

  //! в food передаем настройки,змейку и игр поле
  food.init(settings, snake, board);
  //

  //! в game передаем ссылки на объекты
  game.init(settings, status, board, snake, menu, food);

  //
  //   score.init(settings);

  //! отрисовываем игровое поле
  board.renderBoard();

  //! отрисов. змейку
  board.renderSnake();

  //! создаем новую еду
  food.setNewFood();

  //! метод обработчика сотытия клика
  game.run();
});

// изучить принципы SOLID

// Принцип единственной ответственности (Single Responsibility Principle)
// Существует лишь одна причина, приводящая к изменению класса.
// Один класс должен решать только какую-то одну задачу.

// Принцип открытости/закрытости (Open-closed Principle)
// Программные сущности должны быть открыты для расширения, но закрыты для модификации.
// Программные сущности (классы, модули, функции и прочее) должны быть расширяемыми без изменения своего содержимого.

// Принцип подстановки Барбары Лисков (Liskov Substitution Principle)
// Функции, использующие указатели ссылок на базовые классы, должны уметь использовать объекты производных классов, даже не зная об этом.
// Попросту говоря: подкласс/производный класс должен быть взаимозаменяем с базовым/родительским классом.

// Принцип разделения интерфейса (Interface Segregation Principle)
// Нельзя заставлять клиента реализовать интерфейс, которым он не пользуется.
// Это означает, что нужно разбивать интерфейсы на более мелкие, лучше удовлетворяющие конкретным потребностям клиентов.

// Принцип инверсии зависимостей (Dependency Inversion Principle)
// Высокоуровневые модули не должны зависеть от низкоуровневых. Оба вида модулей должны зависеть от абстракций.
// Абстракции не должны зависеть от подробностей. Подробности должны зависеть от абстракций.
// Проще говоря: зависьте от абстракций, а не от чего-то конкретного.

// Инкапсуляция - размещение в одном компоненте/классе/файле/структуре данных/методов/функций/свойств, которые с ними работают(в Board размещать только то относится к полу(таблица, игровое поле, отрисовка и очистка его, отрисовка змейки и еды, проверка на аварию с полем))
