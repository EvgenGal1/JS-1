{
  "version": 3,
  "sources": [
    "Board.js",
    "Food.js",
    "Game.js",
    "main.js",
    "Menu.js",
    "Settings.js",
    "Snake.js",
    "Status.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "../app.js",
  "sourcesContent": [
    "class Board {\r\n  //! this. везде (почти) указывает на объект в котом находиться. здесь Board\r\n  constructor() {\r\n    // получаем доступ к таблице table id=\"game\"\r\n    this.boardEl = document.getElementById(\"game\");\r\n  }\r\n\r\n  /**\r\n   *! Метод получает другие игровые объекты, которые нужны ему для работы.\r\n   * @param {Settings} settings объект настроек.\r\n   * @param {Snake} snake объект змейки.\r\n   */\r\n  //! через метод init мы будем передовать в какойто объект сылки на др объекты.\r\n  //! 1 Мы так конролим от чего зависит наш файл. Видно в самом init\r\n  //! 2 Более низкая связаность файлов, благодаря собственым свойствам (this.settings,this.board и пр.)\r\n  // игровому полю передаем рамеры игров поля и змейку чтоб по кордин. отрисовать её\r\n  init(settings, snake) {\r\n    this.settings = settings;\r\n    this.snake = snake;\r\n  }\r\n\r\n  /**\r\n   *! Метод отрисовывает игровое поле.\r\n   */\r\n  // внешний цикл отрисует строку, а внутрений ячейки в ней. потом опять строка и ячейки\r\n  renderBoard() {\r\n    // очищаем игр.поле\r\n    this.boardEl.innerHTML = \"\";\r\n    // перебираем кол-во строк из настроек (21)\r\n    for (let row = 0; row < this.settings.rowsCount; row++) {\r\n      // создаем тег \"tr\"\r\n      let tr = document.createElement(\"tr\");\r\n      // обращаемся таблице и добавляем  тег \"tr\"\r\n      this.boardEl.appendChild(tr);\r\n\r\n      // смотрим сколько колонок (21)\r\n      for (let col = 0; col < this.settings.colsCount; col++) {\r\n        // создаем тег \"td\"\r\n        let td = document.createElement(\"td\");\r\n        // в tr добавляем td\r\n        tr.appendChild(td);\r\n        // по кругу создаем и добавляем теги td до 21 включительно\r\n        // идем второй раз на внешний цикл. и так до 21\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   *! Метод отрисовывает змейку на доске.\r\n   */\r\n  // метод getSnakeBodyElems будет возращить теги \"td\" которые соответствуют координатам змейки (snake.body) и отрисовывать их присваивая класс snakeBody\r\n  renderSnake() {\r\n    // перемен. snakeBodyElems = у Board, В МЕТОД getSnakeBodyElems (получить элементы тела змейки) передаем массив с координатами из snake.body. Делаем это по сылке (this.snake) на объект Snake\r\n    const snakeBodyElems = this.getSnakeBodyElems(this.snake.body);\r\n    // если в snakeBodyElems чтото есть\r\n    if (snakeBodyElems) {\r\n      // перебираем его\r\n      snakeBodyElems.forEach(function (tdEl) {\r\n        // и каждому тегу \"td\" добавляем класс snakeBody. класс раскрашивает змейку\r\n        tdEl.classList.add(\"snakeBody\");\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   *! Получаем набор тегов td, представляющих тело змейки.\r\n   * @param {array} bodyCoords массив объектов с координатами\r\n   * @returns {HTMLTableCellElement[]|null} возвращается массив тегов td (HTMLTableCellElement - тег td) если были переданы координаты, иначе null.\r\n   */\r\n  getSnakeBodyElems(bodyCoords) {\r\n    // если в массиве длина больше 0\r\n    if (bodyCoords.length > 0) {\r\n      // создаем массив, в который поместим теги\r\n      let bodyElems = [];\r\n      // перебираем массив\r\n      for (let value of bodyCoords) {\r\n        // перемен. elem = в метод getCellEl (получить элемент ячейки) передаем коорд Х и Y. получаем теги \"td\"\r\n        let elem = this.getCellEl(value.x, value.y);\r\n        // в массив , в конец, добавляем\r\n        bodyElems.push(elem);\r\n      }\r\n      // возращаем массив из тегов \"td\"\r\n      return bodyElems;\r\n    }\r\n    // иначе ничего\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   *! Получаем ячейку таблицы.\r\n   * @param {number} x координата по оси х.\r\n   * @param {number} y координата по оси y.\r\n   * @returns {HTMLTableCellElement} тег td\r\n   */\r\n  getCellEl(x, y) {\r\n    // возвращаем Nный  (переданый) элемент  \"tr\" и \"td\" (в виде ссылки). таким образом мы будем получать эту ячейку (тег)\r\n    // скажем первый тег \"tr\" в нем первый тег \"td\"\r\n    return this.boardEl.querySelector(`tr:nth-child(${y}) td:nth-child(${x})`);\r\n  }\r\n\r\n  /**\r\n   *! Метод очищает игровое поле.\r\n   */\r\n  clearBoard() {\r\n    // константа tdElems = получаем все теги \"td\",\r\n    const tdElems = document.querySelectorAll(\"td\");\r\n    // перебираем циклом forEach все теги td\r\n    tdElems.forEach(function (td) {\r\n      // выставляем класс как пустую строку\r\n      td.className = \"\";\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @deprecated Метод больше не используется, т.к. теперь змейка может проходить через стены.\r\n   *\r\n   * Является ли следующий шаг, шагом в стену.\r\n   * @param {Object} nextCellCoords - координаты ячейки, куда змейка собирается сделать шаг.\r\n   * @param {number} nextCellCoords.x\r\n   * @param {number} nextCellCoords.y\r\n   * @returns {boolean}\r\n   */\r\n  // в таблице нумерация идет с 1. в правого верхнего края. по гориз Х, по вертик Y\r\n  isNextStepToWall(nextCellCoords) {\r\n    // переменная nextCell = получаем ячейку таблицы по коорд\r\n    let nextCell = this.getCellEl(nextCellCoords.x, nextCellCoords.y);\r\n    // tcjb коорд идентичны null\r\n    if (nextCell === null) {\r\n      // возврат истина\r\n      return true;\r\n    }\r\n    // иначе ложь\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   *! Метод рисует еду на игровом поле.\r\n   * @param {Object} coords будущее расположение еды на поле\r\n   * @param {number} coords.x координата x\r\n   * @param {number} coords.y координата y\r\n   */\r\n  // принимает рандомные координаты от setNewFood() {}, и дает им класс food\r\n  renderFood(coords) {\r\n    // перемен. foodCell = получаем ячейку таблицы (getCellEl) по принятым коорд\r\n    const foodCell = this.getCellEl(coords.x, coords.y);\r\n    // приписываем класс\r\n    foodCell.classList.add(\"food\");\r\n  }\r\n\r\n  /**\r\n   *! Метод проверяет съела ли змейка еду.\r\n   * @returns {boolean} true если змейка находится на еде, иначе false.\r\n   */\r\n  // `голова на еде`\r\n  didSnakeEatFood() {\r\n    // у еды (таблица(тег td) с классом .food) проверим класслист содержит (contains) ли он змейку (класс snakeBody)\r\n    // если змейка зашла на еду, тогда будут 2 класса (food, snakeBody)\r\n    return this.boardEl.querySelector(\".food\").classList.contains(\"snakeBody\");\r\n  }\r\n}\r\n",
    "class Food {\r\n  constructor() {\r\n    // коорд где храниться еда\r\n    this.x = null;\r\n    this.y = null;\r\n  }\r\n\r\n  /**\r\n   *! Метод init получает другие игровые объекты, которые нужны ему для работы.\r\n   * @param {Settings} settings объект настроек\r\n   * @param {Snake} snake объект змейки\r\n   * @param {Board} board объект игрового поля\r\n   */\r\n  //! через метод init мы будем передовать в какойто объект сылки на др объекты.\r\n  //! 1 Мы так конролим от чего зависит наш файл. Видно в самом init\r\n  //! 2 Более низкая связаность файлов, благодаря собственым свойствам (this.settings,this.board и пр.)\r\n  // настройки - чтоб знала размеры игрвого поля и не появилась за его пределами; змейка - чтоб еда не появилась на ней; игровое поле - чтоб отрисовала еду\r\n  init(settings, snake, board) {\r\n    this.settings = settings;\r\n    this.snake = snake;\r\n    this.board = board;\r\n  }\r\n\r\n  /**\r\n   *! Метод устанавливает новое случайное положение еды на игровом поле.\r\n   */\r\n  setNewFood() {\r\n    // перемен. coords = генерируем случайные коорд с едой\r\n    const coords = this.generateRandomCoordinates();\r\n    // игровому полю передает коорд для отрисовки\r\n    this.board.renderFood(coords);\r\n  }\r\n\r\n  /**\r\n   *! Метод устанавливает на игровом поле еду по текущим координатам.\r\n   */\r\n  setFood() {\r\n    // в метод renderFood предает коорд еды\r\n    this.board.renderFood(this);\r\n  }\r\n\r\n  /**\r\n   *! Метод генерирует новый объект еды со случайным положением на игровом поле\r\n   * @returns {Food}\r\n   */\r\n  generateRandomCoordinates() {\r\n    while (true) {\r\n      //! получаем коорд Х\r\n      // this.x = случайное число (Math.random()(случайное число от 0 до 1, 1 не включая)) умножаем на число колонок (this.settings.colsCount)(чтоб не выходило за пределы поля), прибавляем 1 (для начала - нумерация начинаеться с 1, нет нулевого элемента, и для конца(захватить последнию колонку)) и отбрасываем дробную часть (Math.floor)\r\n      this.x = Math.floor(Math.random() * this.settings.colsCount + 1);\r\n      //! получаем коорд Y\r\n      this.y = Math.floor(Math.random() * this.settings.rowsCount + 1);\r\n      // по этим коорд получим ячейку\r\n      let cell = this.board.getCellEl(this.x, this.y);\r\n      // проверяем ячейку на присутствие значений\r\n      if (cell === null) {\r\n        // если их нет, цикл запускается заново\r\n        continue;\r\n      }\r\n      // проверяем не явлеется ли она телом змейки\r\n      if (cell.classList.contains(\"snakeBody\")) {\r\n        continue;\r\n      }\r\n      // возрашает рандом. коорд. еды\r\n      return this;\r\n    }\r\n  }\r\n}\r\n",
    "class Game {\r\n  //! this везде (почти) указывает на объект в котом находиться. здесь Game\r\n  constructor() {\r\n    // возвращаемый идентефикатор функции SetInterval\r\n    this.tickIdentifier = null;\r\n    // ссылка на div id=message\r\n    this.messageEl = document.getElementById(\"message\");\r\n  }\r\n\r\n  /**\r\n   *! Метод получает другие игровые объекты, которые нужны ему для работы.\r\n   * @param {Settings} settings\r\n   * @param {Status} status\r\n   * @param {Board} board\r\n   * @param {Snake} snake\r\n   * @param {Menu} menu\r\n   * @param {Food} food\r\n   * @param {Score} score\r\n   */\r\n  //! через метод init мы будем передовать в какойто объект сылки на др объекты.\r\n  //! 1 Мы так конролим от чего зависит наш файл. Видно в самом init\r\n  //! 2 Более низкая связаность файлов, благодаря собственым свойствам (this.settings,this.board и пр.)\r\n  init(settings, status, board, snake, menu, food, score) {\r\n    this.settings = settings;\r\n    this.status = status;\r\n    this.board = board;\r\n    this.snake = snake;\r\n    this.menu = menu;\r\n    this.food = food;\r\n    this.score = score;\r\n  }\r\n\r\n  /**\r\n   *! Метод назначает обработчики на события клика на кнопки \"Старт\", \"Пауза\", а также на стрелки на клавиатуре.\r\n   */\r\n  run() {\r\n    //  this.score.setToWin(this.settings.winLength);\r\n    // у объекта game по ссылке на menu вызываем метод addButtonsClickListeners, которая передает туда функции\r\n    this.menu.addButtonsClickListeners(\r\n      // ссылка на функцию старт\r\n      //! метод bind (привязывать) создает такую же функц что перед ним(сейчас start), но для того что передаем в нём(сейчас объект Game)\r\n      // в результате вернёться функция \"f bound start()\".bound -связаный. привязаный this\r\n      //(bind(this)жестко привязывает к Game и тут же передаеться в метод addButtonsClickListeners)\r\n      //! this указывает на то кто вызывает функцию\r\n      //это нужно для дальнейшего использования в Game, потому что функцию start вызывает кнопка startBtnEl из объекта Menu.\r\n      this.start.bind(this),\r\n      // ссылка на  функц пауза\r\n      this.pause.bind(this)\r\n    );\r\n    // слушаем событие keydown (нажатие \"на кнопку\") - выполн функц pressKeyHandler(направляет змейку по кнопкам), bind(this)(привязанную к Game)\r\n    document.addEventListener(\"keydown\", this.pressKeyHandler.bind(this));\r\n  }\r\n\r\n  /**\r\n   *! Метод запускает игру.\r\n   */\r\n  start() {\r\n    // если статус \"на паузе\"\r\n    if (this.status.isPaused()) {\r\n      // ставим статус что \"играть\"\r\n      this.status.setPlaying();\r\n      //! перемен tickIdentifier = вызов метода setInterval (вызов функц через интервал), для фун.doTick, через 1 сек деленую на скорость змейки.\r\n      this.tickIdentifier = setInterval(\r\n        // метод setInterval будет вызывать объект windows, но для дальнейшей работы, методом bind, создаем новую функцию doTick, в самом Game\r\n        this.doTick.bind(this),\r\n        // вызываем через каждую секунду делённую на скорость. чем больше скорость змейки, тем чаше обновляеться изменения на поле\r\n        1000 / this.settings.speed\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   *! Метод ставит игру на паузу.\r\n   */\r\n  // императивный код(говорим как делать, по шагам)\r\n  pause() {\r\n    //если статус \"играем\"\r\n    if (this.status.isPlaying()) {\r\n      // ставим статус \"пауза\"\r\n      this.status.setPaused();\r\n      // останавливаем игру (остановл вызов фун tickIdentifier)\r\n      clearInterval(this.tickIdentifier);\r\n    }\r\n  }\r\n\r\n  /**\r\n   *! Этот метод запускается каждую секунду и осуществляет:\r\n   * 1. перемещение змейки\r\n   * 2. проверяет проиграна/выиграна ли игра\r\n   * 3. увеличивает размер змейки если она ест еду\r\n   * 4. заново отрисовывает положение змейки и еды\r\n   * ! Двигает всё игру\r\n   */\r\n  // только декларативный код(говорим что делать, а не как делать )\r\n  doTick() {\r\n    // метод меняет координаты змейки\r\n    this.snake.performStep();\r\n    //  this.score.setCurrent(this.snake.body.length);\r\n    if (this.isSnakeSteppedOntoItself()) {\r\n      return;\r\n    }\r\n    // если вернулась истина из метода isGameWon\r\n    if (this.isGameWon()) {\r\n      // возвращает процесс, прекращает остальные\r\n      return;\r\n    }\r\n    // в board проверяем `находить голова на еде`\r\n    if (this.board.didSnakeEatFood()) {\r\n      // увеличиваем тело змейки\r\n      this.snake.increaseBody();\r\n      // ставим новую еду\r\n      this.food.setNewFood();\r\n    }\r\n    // очищает игровое поле\r\n    this.board.clearBoard();\r\n    // выставляет еду\r\n    this.food.setFood();\r\n    // отрисовывает змейку\r\n    this.board.renderSnake();\r\n  }\r\n\r\n  /**\r\n   *! Метод проверяет выиграна ли игра, останавливает игру, выводит сообщение о выигрыше.\r\n   * @returns {boolean} если длина змейки достигла длины нужной для выигрыша, тогда true, иначе false.\r\n   */\r\n  isGameWon() {\r\n    // если у змейки длина координат равна победной длине из настроек\r\n    if (this.snake.body.length == this.settings.winLength) {\r\n      // останавливает обновления всего, игру\r\n      clearInterval(this.tickIdentifier);\r\n      // в div с id=message выводит смс\r\n      this.setMessage(\"Вы выиграли\");\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Метод проверяет съела ли змейка сама себя.\r\n   * @returns {boolean}\r\n   */\r\n  isSnakeSteppedOntoItself() {\r\n    let cellArr = this.snake.body.map(function (cellCoords) {\r\n      return cellCoords.x.toString() + cellCoords.y.toString();\r\n    });\r\n    let head = cellArr.shift();\r\n    if (cellArr.includes(head)) {\r\n      clearInterval(this.tickIdentifier);\r\n      this.setMessage(\"Вы проиграли\");\r\n      return true;\r\n    }\r\n    return false;\r\n\r\n    /* \r\n        [\r\n            {x: 1, y: 1}\r\n            {x: 1, y: 2}\r\n            {x: 1, y: 3}\r\n        ]\r\n        [\r\n            \"11\", \"12\", \"13\"\r\n        ]\r\n        */\r\n  }\r\n\r\n  /**\r\n   * @deprecated Метод больше не используется, т.к. теперь змейка может проходить через стены.\r\n   *\r\n   * Метод проверяет проиграна ли игра, останавливает игру. В случае проигрыша, выводит сообщение о проигрыше.\r\n   * @returns {boolean} если мы шагнули в стену, тогда true, иначе false.\r\n   */\r\n  isGameLost() {\r\n    // если мы шагнули в стену\r\n    // в board в метод isNextStepToWall передаём коорд тела змейки равые [0]\r\n    if (this.board.isNextStepToWall(this.snake.body[0])) {\r\n      // останавливаем метод tickIdentifier\r\n      clearInterval(this.tickIdentifier);\r\n      // вывод сообщения через метод setMessage\r\n      this.setMessage(\"Вы проиграли\");\r\n      return true;\r\n    }\r\n    // иначе ложь\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   *! В зависимости от нажатой кнопки (вверх, вниз, влево, вправо) будет вызываться соответствующий метод.\r\n   * @param {KeyboardEvent} event\r\n   */\r\n  pressKeyHandler(event) {\r\n    // переключаеться (switch) при событии (event) на клавише (key)\r\n    switch (event.key) {\r\n      // если \"стрелка вверх\"\r\n      case \"ArrowUp\":\r\n        // у змейкм вызываем метод changeDirection и передаём направление\r\n        this.snake.changeDirection(\"up\");\r\n        break;\r\n      case \"ArrowDown\":\r\n        this.snake.changeDirection(\"down\");\r\n        break;\r\n      case \"ArrowLeft\":\r\n        this.snake.changeDirection(\"left\");\r\n        break;\r\n      case \"ArrowRight\":\r\n        this.snake.changeDirection(\"right\");\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   *! Метод выводит сообщение на странице.\r\n   * @param {string} text\r\n   */\r\n  // принимает параметр\r\n  setMessage(text) {\r\n    // обращаеться к div id=message и вписывает принятый текст\r\n    this.messageEl.innerText = text;\r\n  }\r\n}\r\n",
    "// ждем когда всё загрузится и потом выполняем\r\nwindow.addEventListener(\"load\", () => {\r\n  // объект класса settings\r\n  // объект настроек\r\n  const settings = new Settings();\r\n  // статус\r\n  const status = new Status();\r\n  // объект змейки\r\n  const snake = new Snake();\r\n  // объект (класс) игрового поля\r\n  const board = new Board();\r\n  // объект меню. отвечает за работу кнопок (старт, пауза)\r\n  const menu = new Menu();\r\n  // еда\r\n  const food = new Food();\r\n  // объект игры\r\n  const game = new Game();\r\n  //   const score = new Score();\r\n\r\n  //! передаем свои настройки\r\n  // в классе settings метод init (установка начальных значений). в виде объекта передаем настройки для нашей игры(скорость, длина для выйгрыша)\r\n  settings.init({ speed: 5, winLength: 5 });\r\n\r\n  //\r\n  //   snake.init(settings);\r\n\r\n  //! передаем в board через init, настройки и змейку\r\n  board.init(settings, snake);\r\n\r\n  //! в food передаем настройки,змейку и игр поле\r\n  food.init(settings, snake, board);\r\n  //\r\n\r\n  //! в game передаем ссылки на объекты\r\n  game.init(settings, status, board, snake, menu, food);\r\n\r\n  //\r\n  //   score.init(settings);\r\n\r\n  //! отрисовываем игровое поле\r\n  board.renderBoard();\r\n\r\n  //! отрисов. змейку\r\n  board.renderSnake();\r\n\r\n  //! создаем новую еду\r\n  food.setNewFood();\r\n\r\n  //! метод обработчика сотытия клика\r\n  game.run();\r\n});\r\n\r\n// изучить принципы SOLID\r\n\r\n// Принцип единственной ответственности (Single Responsibility Principle)\r\n// Существует лишь одна причина, приводящая к изменению класса.\r\n// Один класс должен решать только какую-то одну задачу.\r\n\r\n// Принцип открытости/закрытости (Open-closed Principle)\r\n// Программные сущности должны быть открыты для расширения, но закрыты для модификации.\r\n// Программные сущности (классы, модули, функции и прочее) должны быть расширяемыми без изменения своего содержимого.\r\n\r\n// Принцип подстановки Барбары Лисков (Liskov Substitution Principle)\r\n// Функции, использующие указатели ссылок на базовые классы, должны уметь использовать объекты производных классов, даже не зная об этом.\r\n// Попросту говоря: подкласс/производный класс должен быть взаимозаменяем с базовым/родительским классом.\r\n\r\n// Принцип разделения интерфейса (Interface Segregation Principle)\r\n// Нельзя заставлять клиента реализовать интерфейс, которым он не пользуется.\r\n// Это означает, что нужно разбивать интерфейсы на более мелкие, лучше удовлетворяющие конкретным потребностям клиентов.\r\n\r\n// Принцип инверсии зависимостей (Dependency Inversion Principle)\r\n// Высокоуровневые модули не должны зависеть от низкоуровневых. Оба вида модулей должны зависеть от абстракций.\r\n// Абстракции не должны зависеть от подробностей. Подробности должны зависеть от абстракций.\r\n// Проще говоря: зависьте от абстракций, а не от чего-то конкретного.\r\n\r\n// Инкапсуляция - размещение в одном компоненте/классе/файле/структуре данных/методов/функций/свойств, которые с ними работают(в Board размещать только то относится к полу(таблица, игровое поле, отрисовка и очистка его, отрисовка змейки и еды, проверка на аварию с полем))\r\n",
    "class Menu {\r\n  constructor() {\r\n    // получаем button id=startBtn\r\n    this.startBtnEl = document.getElementById(\"startBtn\");\r\n    // получаем button id=pauseBtn\r\n    this.pauseBtnEl = document.getElementById(\"pauseBtn\");\r\n  }\r\n\r\n  /**\r\n   *! Метод назначает переданные функции в качестве обработчиков событий клика на кнопки \"Старт\" и \"Пауза\".\r\n   * @param {Function} startBtnClickHandler\r\n   * @param {Function} pauseBtnClickHandler\r\n   */\r\n  // принимает в два аргумента (start- и pause- BtnClickHandler(обработчики клика кнопок старт и пауза)), параметра из game (в виде функций) и запускает их при клике\r\n  addButtonsClickListeners(startBtnClickHandler, pauseBtnClickHandler) {\r\n    // кнопке старт говорим что при клике вызывай эту функцию\r\n    this.startBtnEl.addEventListener(\"click\", startBtnClickHandler);\r\n    // кнопке пауза назнач. обработку клика для запуска функции\r\n    this.pauseBtnEl.addEventListener(\"click\", pauseBtnClickHandler);\r\n  }\r\n}\r\n",
    "//! если в файле только один класс то его имя пишут с большой буквы (хорошая практика  - один файл - один класс)\r\nclass Settings {\r\n  //! this. везде (почти) указывает на объект в котором находиться. здесь Settings\r\n  /**\r\n   * @param {Object} params - Парметры игры.\r\n   * @param {number} params.rowsCount - количество строк игрового поля.\r\n   * @param {number} params.colsCount - количество колонок игрового поля.\r\n   * @param {number} params.speed - скорость перемещения змейки.\r\n   * @param {number} params.winLength - какую длину надо наесть, чтобы выиграть.\r\n   * @throws {Error} если переданы не верные настройки выбрасывается\r\n   * соответствующая ошибка.\r\n   */\r\n  // один метод на весь класс. объект settings.init({}) будет передоваться в param\r\n  // в метод init(инициализация) принимаем параметры из main\r\n  init(params) {\r\n    //! объект настроек игры по умолчанию\r\n    // rows и cols - строки и колонки табл\r\n    // speed - скорость\r\n    // winLength - длина для победы\r\n    let defaultParams = {\r\n      rowsCount: 21,\r\n      colsCount: 21,\r\n      speed: 2,\r\n      winLength: 50,\r\n    };\r\n    //! в настройки по умолчанию заменяем передаными настройками.\r\n    // метод Object.assign (копирует с заменой(справо на лево)) из params в defaultParams\r\n    // speed по умолч: было 2 стало 5, winLength по умолч: было 50 стало 5\r\n    Object.assign(defaultParams, params);\r\n\r\n    //! проверка на строки\r\n    // если кол-во строк  меньше 10 или больше 30 выбрасываем ощибку\r\n    if (defaultParams.rowsCount < 10 || defaultParams.rowsCount > 30) {\r\n      throw new Error(\r\n        \"Неверные настройки, значение rowsCount должно быть в диапазоне [10, 30].\"\r\n      );\r\n    }\r\n    // если прошли проверку, то количество строк, сохраняем в свойство (rowsCount) объекта (settings) настроек\r\n    this.rowsCount = defaultParams.rowsCount;\r\n\r\n    //! проверка на колонки\r\n    if (defaultParams.colsCount < 10 || defaultParams.colsCount > 30) {\r\n      throw new Error(\r\n        \"Неверные настройки, значение rowsCount должно быть в диапазоне [10, 30].\"\r\n      );\r\n    }\r\n    this.colsCount = defaultParams.colsCount;\r\n\r\n    //! проверка на скорость\r\n    if (defaultParams.speed < 1 || defaultParams.speed > 10) {\r\n      throw new Error(\r\n        \"Неверные настройки, значение speed должно быть в диапазоне [1, 10].\"\r\n      );\r\n    }\r\n    this.speed = defaultParams.speed;\r\n\r\n    //! проверка на выйгрышную длину\r\n    if (defaultParams.winLength < 5 || defaultParams.winLength > 50) {\r\n      throw new Error(\r\n        \"Неверные настройки, значение winLength должно быть в диапазоне [5, 50].\"\r\n      );\r\n    }\r\n    this.winLength = defaultParams.winLength;\r\n  }\r\n}\r\n",
    "class Snake {\r\n  //! this. везде (почти) указывает на объект в котом находиться. здесь Snake\r\n  constructor() {\r\n    //! массив с возможными направлениями змейки\r\n    this.possibleDirections = [\"down\", \"up\", \"left\", \"right\"];\r\n\r\n    //! массив с координ. змейки (верхн. левый угол х0, у0)\r\n    this.body = [\r\n      {\r\n        x: 1,\r\n        y: 1,\r\n      },\r\n    ];\r\n\r\n    //! направл. по умолчанию - вниз\r\n    this.direction = \"down\";\r\n  }\r\n\r\n  /**\r\n   * @param {Settings} settings настройки игры\r\n   */\r\n  init(settings) {\r\n    this.settings = settings;\r\n  }\r\n\r\n  /**\r\n   *! Меняем направление движения.\r\n   * @param {string} direction направление может быть down, up, left, right.\r\n   * @throws {Error} при передаче не корректного направления выбрасывается ошибка.\r\n   */\r\n  // принимает направления от pressKeyHandler из Game\r\n  changeDirection(newDirection) {\r\n    // если переданое направление нет среди possibleDirections, не includes (не включает в себя)\r\n    if (!this.possibleDirections.includes(newDirection)) {\r\n      // выбрасываем (throw) новую ошибку\r\n      throw new Error(\r\n        \"Передано не верное направление. Вы передали: \" + newDirection\r\n      );\r\n    }\r\n    // в метод isPassedOppositeDirection передаем (переданое направление). если переданое направ. являеться противоположным, возрашаеться истина\r\n    if (this.isPassedOppositeDirection(newDirection)) {\r\n      // return (вернуть) не позволит выполнится коду ниже\r\n      return;\r\n    }\r\n    // в свойство direction (направление) записываем новое направление(то что передали)\r\n    this.direction = newDirection;\r\n  }\r\n\r\n  /**\r\n   *! Метод проверяет, является ли переданное направление, противоположным тому куда сейчас движется змейка.\r\n   * @param {string} newDirection новое направление, может быть up, down, right, left.\r\n   * @returns {boolean} true если новое направление противоположно текущему, иначе false.\r\n   */\r\n  // `передано в противоположном направлении` (с переданым параметром)\r\n  isPassedOppositeDirection(newDirection) {\r\n    // если направление = \"вниз\" и перед.направ. = \"верх\"\r\n    if (this.direction == \"down\" && newDirection == \"up\") {\r\n      // возврашаем истину.\r\n      return true;\r\n    }\r\n    if (this.direction == \"up\" && newDirection == \"down\") {\r\n      return true;\r\n    }\r\n    if (this.direction == \"left\" && newDirection == \"right\") {\r\n      return true;\r\n    }\r\n    if (this.direction == \"right\" && newDirection == \"left\") {\r\n      return true;\r\n    }\r\n    // если нет противоположных направлений, возвращяем ложь\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   *! Метод осуществляет шаг змейки. Добавляет ячейку перед существующим положением головы и удаляет одну ячейку в хвосте.\r\n   */\r\n  // `выполнить шаг`\r\n  performStep() {\r\n    // берем текущие коорд головы (в массиве первый элемент[0])\r\n    let currentHeadCoords = this.body[0];\r\n    // копируем их в переменную\r\n    let newHeadCoords = {\r\n      x: currentHeadCoords.x,\r\n      y: currentHeadCoords.y,\r\n    };\r\n    // смотрим какое направление\r\n    switch (this.direction) {\r\n      // если \"вниз\" то по Y + 1\r\n      case \"down\":\r\n        newHeadCoords.y++;\r\n        break;\r\n      // если \"вверх\" то - 1 по коорд Y\r\n      case \"up\":\r\n        newHeadCoords.y--;\r\n        break;\r\n      // если в \"лево\" по X коорд - 1\r\n      case \"left\":\r\n        newHeadCoords.x--;\r\n        break;\r\n      // если в \"право\" по X коорд + 1\r\n      case \"right\":\r\n        newHeadCoords.x++;\r\n        break;\r\n    }\r\n\r\n    //  //если голова уходит за правый край\r\n    //  if (newHeadCoords.x > this.settings.colsCount) {\r\n    //    newHeadCoords.x = 1;\r\n    //  }\r\n    //  //если голова уходит за нижний край\r\n    //  if (newHeadCoords.y > this.settings.rowsCount) {\r\n    //    newHeadCoords.y = 1;\r\n    //  }\r\n    //  //если голова уходит за левый край\r\n    //  if (newHeadCoords.x == 0) {\r\n    //    newHeadCoords.x = this.settings.colsCount;\r\n    //  }\r\n    //  //если голова уходит за верхний край\r\n    //  if (newHeadCoords.y == 0) {\r\n    //    newHeadCoords.y = this.settings.rowsCount;\r\n    //  }\r\n\r\n    // в dody добавляем в начале (новую ячейку)\r\n    this.body.unshift(newHeadCoords);\r\n    // удаляем в конце(последнию ячейку)\r\n    this.body.pop();\r\n  }\r\n\r\n  /**\r\n   *! Метод дублирует в массиве объектов представляющих тело змейки последнюю ячейку, т.е. в массиве в конце оказываются два одинаковых объекта.\r\n   * Когда метод performStep в самом конце удаляет последний элемент массива, он удаляет сдублированный объект, таким образом тело змейки растет.\r\n   */\r\n  //`увеличить тело`\r\n  // императивный код(говорим как делать, по шагам)\r\n  increaseBody() {\r\n    // переменная `последняя ячейка тела` = обрашаемся к массиву body[берем его последний элемент\r\n    // (длина массива - 1(нумерация элементов с 0, потому из длины массива, скажем 3, - 1, будет 2, и это 3 элемент по счету, т.е. 0,1,2 ))]\r\n    let bodyLastCell = this.body[this.body.length - 1];\r\n    // в переменную newBodyLastCell записываем коорд последней ячейки\r\n    let newBodyLastCell = {\r\n      x: bodyLastCell.x,\r\n      y: bodyLastCell.y,\r\n    };\r\n    // к теле змейки добавляем в конце такую же ячейку\r\n    this.body.push(newBodyLastCell);\r\n  }\r\n}\r\n",
    "/** Здесь будет хранится статус игры, например играем мы, завершили или остановлено. */\r\nclass Status {\r\n  constructor() {\r\n    // при открытие страницы сразу ставим на паузу\r\n    this.setPaused();\r\n  }\r\n\r\n  //! Это значит что мы играем.\r\n  // включает игру\r\n  setPlaying() {\r\n    // condition (состояние) играем\r\n    this.condition = \"playing\";\r\n  }\r\n\r\n  //!Это значит что игра на паузе.\r\n  setPaused() {\r\n    this.condition = \"paused\";\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} если мы сейчас играем, тогда true, иначе false.\r\n   */\r\n  // проверяет включена ли игра\r\n  isPlaying() {\r\n    return this.condition === \"playing\";\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} если сейчас игра на паузе, тогда true, иначе false.\r\n   */\r\n  isPaused() {\r\n    return this.condition === \"paused\";\r\n  }\r\n}\r\n"
  ]
}
